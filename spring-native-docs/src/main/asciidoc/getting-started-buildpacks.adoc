[[getting-started-buildpacks]]
=== Getting started with Buildpacks

This section gives you a practical overview of building a Spring Boot native application using {spring-boot-docs}/html/spring-boot-features.html#boot-features-container-images-buildpacks[Cloud Native Buildpacks].
This is a practical guide that uses the https://spring.io/guides/gs/rest-service/[RESTful Web Service getting started guide].

==== System Requirements

Docker should be installed, see https://docs.docker.com/installation/#installation[Get Docker] for more details.
Before proceeding further, make sure you can use `docker` from the shell.

TIP: On MacOS, it is recommended to increase the memory allocated to Docker to at least `8GB`, and potentially add more CPUs as well.
See this https://stackoverflow.com/questions/44533319/how-to-assign-more-memory-to-docker-container/44533437#44533437[Stackoverflow answer] for more details.
On Microsoft Windows, make sure to enable the https://docs.docker.com/docker-for-windows/wsl/[Docker WSL 2 backend] for better performance.

==== Sample Project Setup

The completed "RESTful Web Service" guide can be retrieved using the following commands:

====
[source,bash]
----
git clone https://github.com/spring-guides/gs-rest-service
cd gs-rest-service/complete
----
====

===== Validate Spring Boot version

IMPORTANT: Only Spring Boot {spring-boot-version} is supported, so change the version if necessary.

====
[source,xml,subs="attributes,verbatim",role="primary"]
.Maven
----
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>{spring-boot-version}</version>
    <relativePath/>
</parent>
----
[source,subs="attributes,verbatim",role="secondary"]
.Gradle Groovy
----
plugins {
    id 'org.springframework.boot' version '{spring-boot-version}'
}
----
[source,Kotlin,subs="attributes,verbatim",role="secondary"]
.Gradle Kotlin
----
plugins {
    id("org.springframework.boot") version "{spring-boot-version}"
}
----
====

===== Add Spring Native

`org.springframework.experimental:spring-native` provides native configuration APIs like `@NativeHint` as well as other mandatory classes required to run a Spring application as a native image.

====
[source,xml,subs="attributes,verbatim",role="primary"]
.Maven
----
<dependencies>
    <dependency>
        <groupId>org.springframework.experimental</groupId>
        <artifactId>spring-native</artifactId>
        <version>{version}</version>
    </dependency>
</dependencies>
----
[source,subs="attributes,verbatim",role="secondary"]
.Gradle Groovy
----
dependencies {
    implementation 'org.springframework.experimental:spring-native:{version}'
}
----
[source,Kotlin,subs="attributes,verbatim",role="secondary"]
.Gradle Kotlin
----
dependencies {
    implementation("org.springframework.experimental:spring-native:{version}")
}
----
====

===== Add the Spring AOT plugin

The Spring AOT plugin performs ahead-of-time transformations required to improve native image compatibility and footprint.

TIP: The transformations also apply to the JVM so this can be applied regardless.

====
[source,xml,subs="attributes,verbatim",role="primary"]
.Maven
----
<build>
    <plugins>
        <!-- ... -->
        <plugin>
            <groupId>org.springframework.experimental</groupId>
            <artifactId>spring-aot-maven-plugin</artifactId>
            <version>{version}</version>
            <executions>
                <execution>
                    <id>test-generate</id>
                    <goals>
                        <goal>test-generate</goal>
                    </goals>
                </execution>
                <execution>
                    <id>generate</id>
                    <goals>
                        <goal>generate</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
----
====

The plugin provides a number of options to customize the transformations, see <<configuring-spring-aot>> for more details.

TODO: Add Gradle configuration

===== Enable native image support

Spring Boot's {spring-boot-docs}/html/spring-boot-features.html#boot-features-container-images-buildpacks[Cloud Native Buildpacks support] lets you build a container for your Spring Boot application.
The https://github.com/paketo-buildpacks/spring-boot-native-image[Packeto implementation] has an option to build a native image that can be enabled as follows:

====
[source,xml,subs="attributes,verbatim",role="primary"]
.Maven
----
<plugin>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-maven-plugin</artifactId>
    <configuration>
        <image>
            <builder>paketobuildpacks/builder:tiny</builder>
            <env>
                <BP_BOOT_NATIVE_IMAGE>true</BP_BOOT_NATIVE_IMAGE>
            </env>
        </image>
    </configuration>
</plugin>
----
[source,subs="attributes,verbatim",role="secondary"]
.Gradle Groovy
----
bootBuildImage {
    builder = "paketobuildpacks/builder:tiny"
    environment = [
        "BP_BOOT_NATIVE_IMAGE" : "true"
    ]
}
----
[source,Kotlin,subs="attributes,verbatim",role="secondary"]
.Gradle Kotlin
----
tasks.getByName<BootBuildImage>("bootBuildImage") {
    builder = "paketobuildpacks/builder:tiny"
    environment = mapOf(
            "BP_BOOT_NATIVE_IMAGE" to "true"
    )
}
----
====

NOTE: The builder is also customized to use `paketobuildpacks/builder:tiny`, `paketobuildpacks/builder:base` being the default, but less optimized.

TIP: Additional `native-image` arguments can be added using the `BP_BOOT_NATIVE_IMAGE_BUILD_ARGUMENTS` environment variable.

TODO: Update to `BP_NATIVE_IMAGE` and `BP_NATIVE_IMAGE_BUILD_ARGUMENTS` when Buildpacks have been updated.

ifeval::["{spring-native-repo}" != "release"]
===== Maven Repository

Configure your build to include the required repository for the `spring-native` dependency, as follows:

====
[source,xml,subs="attributes,verbatim",role="primary"]
.Maven
----
<repositories>
    <repository>
        <id>spring-{spring-native-repo}</id>
        <name>Spring {spring-native-repo}</name>
        <url>https://repo.spring.io/{spring-native-repo}</url>
    </repository>
</repositories>
----
[source,subs="attributes,verbatim",role="secondary"]
.Gradle Groovy
----
repositories {
    maven { url 'https://repo.spring.io/{spring-native-repo}' }
}
----
[source,Kotlin,subs="attributes,verbatim",role="secondary"]
.Gradle Kotlin
----
repositories {
    maven { url = uri("https://repo.spring.io/{spring-native-repo}") }
}
----
====

The Spring AOT plugin also requires a dedicated plugin repository:
====
[source,xml,subs="attributes,verbatim",role="primary"]
.Maven
----
<pluginRepositories>
    <pluginRepository>
        <id>spring-{spring-native-repo}</id>
        <name>Spring {spring-native-repo}</name>
        <url>https://repo.spring.io/{spring-native-repo}</url>
    </pluginRepository>
</pluginRepositories>
----
[source,subs="attributes,verbatim",role="secondary"]
.Gradle Groovy
----
pluginManagement {
    repositories {
        maven { url 'https://repo.spring.io/{spring-native-repo}' }
    }
}
----
[source,Kotlin,subs="attributes,verbatim",role="secondary"]
.Gradle Kotlin
----
pluginManagement {
    repositories {
        maven { url = uri("https://repo.spring.io/{spring-native-repo}") }
    }
}
----
====
endif::[]

==== Build the native application

The native application can be built as follows:
====
[source,bash,role="primary"]
.Maven
----
$ mvn spring-boot:build-image
----
[source,bash,role="secondary"]
.Gradle Groovy
----
$ gradle bootBuildImage
----
[source,bash,role="secondary"]
.Gradle Kotlin
----
$ gradle bootBuildImage
----
====

This creates a Linux container to build the native application using the GraalVM native image compiler.
By default, the container image is installed locally.

==== Run the native application

To run the application, you can use `docker` the usual way as shown in the following example:

====
[source,bash]
----
$ docker run -p 8080:8080 docker.io/library/rest-service:0.0.1-SNAPSHOT
----
====

If you prefer `docker-compose`, you can write a `docker-compose.yml` at the root of the project with the following content:
====
[source,yaml]
----
version: '3.1'
services:
  rest-service:
    image: rest-service:0.0.1-SNAPSHOT
    ports:
      - "8080:8080"
----
====

And then run
====
[source,bash]
----
$ docker-compose up
----
====

The startup time should be less than `100ms`, compared to the roughly `1500ms` when starting the application on the JVM.

Now that the service is up, visit `http://localhost:8080/greeting`, where you should see:

====
[source,json]
----
{"id":1,"content":"Hello, World!"}
----
====

